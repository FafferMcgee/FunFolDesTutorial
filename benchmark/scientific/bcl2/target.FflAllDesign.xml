<ROSETTASCRIPTS>

  <SCOREFXNS>

    # A weight is added to small-range hbonds to favor helix
    # aa_composition is used to favor the correct type of residues
    # in helical residues (requires AddHelixSequenceConstraints).
    <ScoreFunction name="fullatom" weights="talaris2014">
      <Reweight scoretype="hbond_sr_bb"    weight="1.6"/>
      <Reweight scoretype="aa_composition" weight="1.0" />
    </ScoreFunction>

  </SCOREFXNS>

  <RESIDUE_SELECTORS>
    # Standard FFL ResidueSelectors.
    <xi:include href="xml_pieces/selectors.xml" />

    # Target: pdbs/4oyd.pdb.gz: COMPUTATIONALLY DESIGNED INHIBITOR
    <Index name="query_motif"  resnums="43B-64B" />
    <Not   name="!query_motif" selector="query_motif" />
    <Chain name="chB"          chains="B" />
    <Chain name="binder"       chains="A" />
    <And   name="template_chB" selectors="!query_motif,chB" />


    # Target: pdbs/4oyd.pdb.gz: COMPUTATIONALLY DESIGNED INHIBITOR
    # We need this to compare the RMSD of our design with it, as we are
    # expecting our design to get closer to this.
    # We cannot use a chain selector as this crystal is 1 residue longer,
    # so we have to take them out (from the C-term).
    <Index name="target_region" resnums="1B-116B" />

    # Alignment selector can be applied to both the final design and the target.
    # This is required to do a non-global alignemnt RMSD.
    # This selector means that we are aligning through the inserted motif wihtout
    # the flexible regions assigned to it.
    <Index name="target_alignment" resnums="45B-62B" />

    # When comparing with the target structure, we can do it for all the structure
    # or just for those residues that should be alpha helix (there is no garantee
    # they will be so in the designs, though).
    <Index name="target_h1"  resnums="2B-33B" />
    <Index name="target_h2"  resnums="39B-75B" />
    <Index name="target_h3"  resnums="82B-115B" />
    <Or name="target_alphas" selectors="target_h1,target_h2,target_h3" />

    # Or we can even just compare at the level of the 3 helices just in contact
    # with the binder helix, thus avoiding the derivation produced due to the length
    # of the helices.
    <Index name="target_lh1"       resnums="10B-31B" />
    <Index name="target_lh2"       resnums="43B-64B" />
    <Index name="target_lh3"       resnums="95B-114B" />
    <Or name="target_local_alphas" selectors="target_lh1,target_lh2,target_lh3" />

  </RESIDUE_SELECTORS>

  <MOVE_MAP_FACTORIES>
    # Standard FFL MoveMap
    <xi:include href="xml_pieces/movemap.xml" />
    <MoveMapFactory name="FULL_MOVEMAP" bb="true" chi="true" nu="true" branches="false" jumps="false" />
  </MOVE_MAP_FACTORIES>

  <TASKOPERATIONS>
    # Standard FFL TaskOperators
    <xi:include href="xml_pieces/taskoperators.xml" />
    <OperateOnResidueSubset name="NOEDIT_TASKOP" selector="HOTSPOT_OR_CONTEXT_AND_!FLEXIBLE" >
      <RestrictToRepackingRLT/>
    </OperateOnResidueSubset>
    <OperateOnResidueSubset name="NOCYS_TASKOP" selector="COLDSPOT_OR_TEMPLATE" >
      <DisallowIfNonnativeRLT disallow_aas="C" />
    </OperateOnResidueSubset>
  </TASKOPERATIONS>

  <FILTERS> # (confidence=0 -> to score not to filter)
    # Check global RMSD against starting Pose (4OYD.pdb)
    <RmsdFromResidueSelectorFilter name="GRMSD2Target"
      reference_name="target_pose" reference_selector="target_region" query_selector="chB" confidence="0" />
    # Check RMSD against starting Pose (4OYD.pdb) aligned through the inserted region
    # Needs to be preceded by an alignment through the region of interest
    <RmsdFromResidueSelectorFilter name="LRMSD2Target"  superimpose="false"
      reference_name="target_pose" reference_selector="target_region" query_selector="chB" confidence="0" />
    # Check RMSD against starting Pose (4OYD.pdb) aligned through the inserted region only for alhpa helices
    # Needs to be preceded by an alignment through the region of interest
    <RmsdFromResidueSelectorFilter name="LHRMSD2Target"  superimpose="false"
      reference_name="target_pose" reference_selector="target_alphas" query_selector="target_alphas" confidence="0" />
    # Check RMSD against starting Pose (4OYD.pdb) aligned through the inserted region only for alhpa helices regions
    # in contact with the binding motif. Needs to be preceded by an alignment through the region of interest
    <RmsdFromResidueSelectorFilter name="LLHRMSD2Target"  superimpose="false"
      reference_name="target_pose" reference_selector="target_local_alphas" query_selector="target_local_alphas" confidence="0" />
    # Make sure to get an evaluation of the design alone
    <ScorePoseSegmentFromResidueSelectorFilter name="design_score" confidence="0"
            residue_selector="chB" scorefxn="fullatom" />
  </FILTERS>

  <MOVERS>
    # ** SavePoseMover used like this does not need to be called during PROTOCOL to work.
    <SavePoseMover name="load_target"   reference_name="target_pose"   pdb_file="pdbs/4oyd.pdb.gz" />

    # We mimick the FFL labeling so we can apply the same MoveMap and Design TaskOperations
    <LabelPoseFromResidueSelectorMover name="labelMOTIF"    property="MOTIF"    residue_selector="query_motif" />
    <LabelPoseFromResidueSelectorMover name="labelTEMPLATE" property="TEMPLATE" residue_selector="template_chB" />
    <LabelPoseFromResidueSelectorMover name="labelCONTEXT"  property="CONTEXT"  residue_selector="binder" />
    <LabelPoseFromResidueSelectorMover name="labelHOTSPOT"  property="HOTSPOT"  residue_selector="query_motif" />

    # This is good to have to see a schema of what residues are going to be affected in which way
    <DisplayPoseLabelsMover name="showDesign" />

    # For an helix bundle, this should be usefull
    <AddHelixSequenceConstraints name="addHComp" />
    # Edit the sequence to stabilize the protein
    <FastDesign name="DesignRelax" scorefxn="fullatom" clear_designable_residues="true"
               task_operations="NOEDIT_TASKOP,NOCYS_TASKOP"
               repeats="3" delete_virtual_residues_after_FastRelax="true"
               movemap_factory="FULL_MOVEMAP" >
    </FastDesign>

    # Local alignment for final evaluation
    <AlignByResidueSelectorMover name="align" reference_name="target_pose"
      reference_selector="target_alignment" query_selector="target_alignment" />

  </MOVERS>

  <PROTOCOLS>
    # Mimick FFL labeling
    <Add mover="labelMOTIF" />
    <Add mover="labelTEMPLATE" />
    <Add mover="labelCONTEXT" />
    <Add mover="labelHOTSPOT" />
    # Design
    <Add mover="addHComp" />
    <Add mover="DesignRelax" />
    # Evaluate
    <Add filter="GRMSD2Target" />
    <Add mover="align" />
    <Add filter="LRMSD2Target" />
    <Add filter="LHRMSD2Target" />
    <Add filter="LLHRMSD2Target" />
    <Add filter="design_score" />
  </PROTOCOLS>

</ROSETTASCRIPTS>
