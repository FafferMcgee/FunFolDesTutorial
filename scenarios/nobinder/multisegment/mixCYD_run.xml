<ROSETTASCRIPTS>

  <SCOREFXNS>
    #Â FULL ATOM SCORE FUNCTION
    #   Needed for the Design process and the final closure.
    #   Because we have multiple static segments in a given protein,
    #   chainbreaks are needed to allow backbone flexibility. Thus,
    #   the system needs to be aware of chainbreak scores to promote its
    #   closure.
    <ScoreFunction name="fullatom" weights="talaris2014" >
      <Reweight scoretype="chainbreak"         weight="1.0"/>
      <Reweight scoretype="linear_chainbreak"  weight="1.0"/>
      <Reweight scoretype="overlap_chainbreak" weight="1.0"/>
    </ScoreFunction>
  </SCOREFXNS>

  <RESIDUE_SELECTORS>
    # Standard FFL ResidueSelectors.
    <xi:include href="xml_pieces/selectors.xml" />

    # TEMPLATE and MOTIF pose.
    #   In this example we are doing an insertion of several segments
    #   of a protein over itself. Thus, template and motif pose are
    #   the same. As before, we need to define our template chain to
    #   make sure that our template has ONLY ONE CHAIN.
    <Chain name="designChain"  chains="A" />
    <Not   name="!designChain" selector="designChain" />

    #   In this particular example, there is non-aa content in chain A.
    #   Even with ignore_unrecognized_residues these other molecules are there
    #   nonetheless. This is incompatible neither with StructFragmentMover or with
    #   NubInitioMover. By combining the template chain selector with the PROTEIN
    #   selector we can make sure that we do not have this issue.
    <And name="designProtChain"  selectors="PROTEIN,designChain" />
    <Not name="!designProtChain" selector="designProtChain" />

    # INSERTION and MOTIF region selection (in this case, it is the same).
    <Index name="motif1"    resnums="54A-58A" />
    <Index name="motif2"    resnums="62A-68A" />
    <Index name="motif3"    resnums="112A-115A" />
    <Index name="motif4"    resnums="123A-126A" />
    <Or    name="insertion" selectors="motif1,motif2,motif3,motif4" />
  </RESIDUE_SELECTORS>

  <MOVE_MAP_FACTORIES>
    # Standard FFL MoveMap
    <xi:include href="xml_pieces/movemap.xml" />
  </MOVE_MAP_FACTORIES>

  <TASKOPERATIONS>
    # Standard FFL TaskOperators
    <xi:include href="xml_pieces/taskoperators.xml" />
  </TASKOPERATIONS>

  <FILTERS>
    # We will check the RMSD between the pose after NubInitioMover and at the end.
    <RmsdFromResidueSelectorFilter name="rmsd_drift" reference_name="refolded_pose"
      reference_selector="designProtChain" query_selector="designProtChain" confidence="0" />
    # We will check at the end the final RMSD between the template and the Design
    <RmsdFromResidueSelectorFilter name="final_rmsd" confidence="0"
        reference_name="template_pose" reference_selector="designProtChain"
        query_selector="designChain" />
  </FILTERS>

  <MOVERS>
    # EXTRA POSES TO SAVE/LOAD:
    #   We will SAVE the TEMPLATE (input pose) to measure the FINAL RMSD of the design.
    <SavePoseMover name="saveTemplate" restore_pose="0" reference_name="template_pose" />
    #   We will SAVE the REFOLDED POSE before the design process to evaluate the RMSD
    #   DRIFT between it and the final design.
    <SavePoseMover name="saveRefolded" restore_pose="0" reference_name="refolded_pose" />
    #   We will LOAD in parallel the MOTIF POSE from which the MOTIF (and BINDER, if any)
    #   will be obtained. Loading a PDB FILE into the DataMap does not require for this
    #   mover to be called in the PROTOCOL (actually, it should NOT be called).
    #   In this case, this pose is the same as the input, but some memory issues arise, for
    #   some reason if we would use the template_pose as the motif source.
    <SavePoseMover name="load_target" reference_name="target_pose" pdb_file="4zqk.pdb.gz" />

    # The TEMPLATE pose MUST BE A SINGLE, UNBROKEN CHAIN. This is non-negotiable.
    # Extra chains need to be deleted BEFORE starting to create FRAGMENTS.
    # We do it in two steps just to be on the save side.
    <DeleteRegionMover name="removeNonProtein" residue_selector="!PROTEIN" />
    <DeleteRegionMover name="removeExtraChains" residue_selector="!designChain" />

    # FRAGMENT CREATION/LOADING:
    # The creates the fragments (if they need to be created) or loads them from a file
    # into the DataMap with the "frags" identifier (that needs to be specified in the NubInitio).
    <StructFragmentMover name="FragmentPicker" prefix="frags" vall_file="database/vall.jul19.2011.gz"
      output_frag_files="1" small_frag_file="frags.200.3mers" large_frag_file="frags.200.9mers" />

    # Guiding the ab inito with CONSTRAINTS highly improves the results from NubInitioMover.
    <AddConstraints name="addCST" >
      <AtomPairConstraintGenerator name="atompairCST" sd="5.0" ca_only="true" min_seq_sep="6"
        use_harmonic="true" unweighted="true" max_distance="40" residue_selector="designProtChain" />
    </AddConstraints>

    # After folding, we will remove the constraints so that the design process is not guided by
    # constraints that do not belong anymore to our design (they come from the original scaffold).
    <ClearConstraintsMover name="cleanCST" />

    # INSERTION AND REFOLDING
    #   Flexibility is allowed between segment 1 and 2 to improve the chance of closing the chainbreak
    #   between them, as is quite a small segment.
    <NubInitioMover name="FFL" fragments_id="frags" template_motif_selector="insertion" fullatom_scorefxn="fullatom" >
      <Nub reference_name="target_pose" residue_selector="insertion" >
        <Segment order="1" c_term_flex="2" />
        <Segment order="2" n_term_flex="2" />
        <Segment order="3" />
        <Segment order="4" />
      </Nub>
    </NubInitioMover>

    # CLOSURE INSURANCE
    #   This is only needed when working on multi-segment poses. To run at the end of the process.
    #   It will make sure that:
    #     a) design chain is closed.
    #     b) design FOLDTREE is simplified for final output.
    #     c) design CUTPOINT residue types are removed.
    <NubInitioLoopClosureMover name="FFLCCD" fragments_id="frags" break_side_ramp="true" />

    # This mover is very helpful in terms of showing the setup of the pose after the
    # NubInitioMover has been run.
    <DisplayPoseLabelsMover name="showDesign" />

    # SEQUENCE EDITING
    <FastDesign name="DesignRelax" scorefxn="fullatom" delete_virtual_residues_after_FastRelax="true"
      task_operations="FFLMOTIF_TASKOP,FFLFLEX_TASKOP,FFLTEMPLATE_TASKOP,FFLTEMPLATE_DISULFIDES"
      repeats="3" movemap_factory="FFLSTANDARD_MOVEMAP" >
    </FastDesign>

    # This might be helpful in order to latter on analyse the designs in PyMOL
    <ResidueLabelsToPymolSelectionMover name="pymolselect"  pdb_count="true" />
  </MOVERS>

  <PROTOCOLS>
    # Preparing the Template
    <Add mover="removeNonProtein" />
    <Add mover="removeExtraChains" />
    <Add mover="saveTemplate" />
    <Add mover="FragmentPicker" />
    <Add mover="addCST" />
    # Fold
    <Add mover="FFL" />
    <Add mover="saveRefolded" />
    <Add mover="showDesign" />
    # Design
    <Add mover="cleanCST" />
    <Add mover="DesignRelax" />
    <Add mover="FFLCCD" />
    # Evaluate
    <Add filter="rmsd_drift" />
    <Add filter="final_rmsd" />
    <Add mover="pymolselect" />
  </PROTOCOLS>
  <OUTPUT />
</ROSETTASCRIPTS>
